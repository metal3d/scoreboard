//go:build ignore
// +build ignore

package main

import (
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

var loaderTPL = `package i18n

// This file is generated by i18n_generator.go. DO NOT EDIT!

// loadI18n loads all translations
func loadI18n() {
    mutex.Lock()
    defer mutex.Unlock()
{{ range $key, $value := .Translations -}}
    translations["{{$key}}"] = {{ $key }}Translations
{{ end -}}
}

func init() {
    loadI18n()
}
`

var langTPL = `package i18n

// This file is generated by i18n_generator.go. DO NOT EDIT!

var {{.Lang}}Translations = map[string]string{
{{range $key, $value := .Translations}}	{{ $key | printf "%q" }}: {{ $value | printf "%q" }},
{{end}}}

`

// detect I("...")
var ifunc = regexp.MustCompile(`I\(([^)]+)\)`)

func main() {

	log.Println("Generating i18n files...")
	getUntranslated()
	generate()
}

func generate() {
	langFiles, err := filepath.Glob("*.yaml")
	if err != nil {
		log.Fatal(err)
	}
	for _, langFile := range langFiles {
		log.Printf("Processing %s", langFile)
		if err := createGoFile(langFile); err != nil {
			log.Fatal(err)
		}
	}
}

func getUntranslated() {
	keys := make(map[string]bool)

	// recursivelly find all go files in ../ui
	gofiles := make([]string, 0)
	filepath.Walk("../ui", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".go" {
			return nil
		}
		log.Printf("Processing %s", path)
		gofiles = append(gofiles, path)
		return nil
	})

	for _, gofile := range gofiles {
		log.Printf("Processing %s", gofile)
		content, err := os.ReadFile(gofile)
		if err != nil {
			log.Fatal(err)
		}
		matches := ifunc.FindAllStringSubmatch(string(content), -1)
		for _, match := range matches {
			m := match[1]
			//m = m[1 : len(m)-1]
			m = strings.Trim(m, "\"")
			m = strings.Trim(m, "'")
			m = strings.Trim(m, "`")
			keys[m] = true
		}
	}

	// read json files
	langFiles, err := filepath.Glob("*.yaml")
	if err != nil {
		log.Fatal(err)
	}

	// place en_US on top
	for i, langFile := range langFiles {
		if langFile == "en_US.yaml" {
			langFiles[0], langFiles[i] = langFiles[i], langFiles[0]
		}
	}

	// en_US is the base translation, so we use it to fill the missing translations
	translationToLoad := make(map[string]bool)
	baseTranslations := make(map[string]string)

	// read all translations, fill the missing translations with the base translation
	// and write the translations back to the yaml files
	for i, langFile := range langFiles {
		infile, err := os.Open(langFile)
		if err != nil {
			log.Fatal(err)
		}
		defer infile.Close()

		var translations map[string]string
		dec := yaml.NewDecoder(infile)
		err = dec.Decode(&translations)
		if err != nil {
			log.Fatal(err)
		}
		if i == 0 {
			baseTranslations = translations
		}
		for key := range keys {
			if translations[key] == "" {
				log.Printf("Missing translation for `%s` in %s", key, langFile)
				if baseTranslations[key] != "" {
					translations[key] = baseTranslations[key]
				} else {
					translations[key] = key
				}
			}
		}
		out, err := os.Create(langFile)
		if err != nil {
			log.Fatal(err)
		}
		defer out.Close()
		enc := yaml.NewEncoder(out)
		enc.Encode(translations)
		translationToLoad[langFile[:len(langFile)-5]] = true
	}
	createLoader(translationToLoad)
}

func createGoFile(langfile string) error {
	translations := make(map[string]string)
	// read json file

	jsonfile, err := os.Open(langfile)
	if err != nil {
		log.Fatal(err)
	}
	dec := yaml.NewDecoder(jsonfile)
	err = dec.Decode(&translations)
	if err != nil {
		log.Fatal(err)
	}

	// decode unicode
	for key, value := range translations {
		translations[key] = value
	}

	// create go file
	langfile = langfile[:len(langfile)-5] // remove the .json extension
	goFile, err := os.Create(langfile + ".go")
	if err != nil {
		return err
	}
	defer goFile.Close()

	tpl, err := template.New("lang").Parse(langTPL)
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.Execute(goFile, struct {
		Lang         string
		Translations map[string]string
	}{
		Lang:         langfile,
		Translations: translations,
	})
	return err
}

func createLoader(translations map[string]bool) {
	loaderFile, err := os.Create("loader.go")
	if err != nil {
		log.Fatal(err)
	}
	defer loaderFile.Close()

	tpl, err := template.New("loader").Parse(loaderTPL)
	if err != nil {
		log.Fatal(err)
	}
	err = tpl.Execute(loaderFile, struct {
		Translations map[string]bool
	}{
		Translations: translations,
	})
	if err != nil {
		log.Fatal(err)
	}
}
